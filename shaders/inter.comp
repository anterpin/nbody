#version 460


layout (local_size_x = 256) in;
layout (location = 1) uniform float G;
layout (location = 2) uniform float dt;
layout (location = 3) uniform float eps2;
layout (location = 4) uniform float damping;
layout (location = 5) uniform float threshold;
layout (location = 6) uniform int n2;
layout (location = 7) uniform int to_sort;


layout (binding = 0, std430) buffer positions
{
  vec4 pos[];
};

layout (binding = 1, std430) buffer velocities
{
  vec4 vel[];
};

layout (binding = 2, std430) buffer tree
{
  float sizes[];
};

layout (binding = 3, std430) buffer center_of_mass
{
  vec4 com[];
};

layout (binding = 4, std430) buffer children
{
  int chil[];
};

layout (binding = 5, std430) buffer next
{
  int nex[];
};

layout (binding = 6, std430) buffer sorted
{
  int sort[];
};


vec3 interact(vec3 a, vec3 b, float m) {
  vec3 r = a - b;
  float ds = dot(r, r) + eps2;
  return r * m * inversesqrt(ds * ds * ds);
}

vec3 calc_acceleration(vec3 pos) {
    int i = 0;
    vec3 acc = vec3(0);
    while (i != -1) {
      bool cond = chil[i] == 0 || (sizes[i] / distance(com[i].xyz, pos)) < threshold;
      acc += cond ? interact(com[i].xyz, pos, com[i].w) : vec3(0);
      i = cond ? nex[i] : chil[i];
    }
    return acc;
}


void main() {
    uint i = gl_GlobalInvocationID.x;
    uint n = pos.length();
    if (i >= n) return;
    if (to_sort == 1)
      i = sort[i];
    vec3 p = pos[i].xyz;

    vec3 a = vec3(0.0);
    if (n2 == 0) {
      a = calc_acceleration(p);
    } else  {
      for (int k = 0; k < n; k++) {
        vec3 b = pos[k].xyz;
        a += interact(b, p, 1);
      }
    }

    vel[i] = vec4(vel[i].xyz * damping + a * G * dt, 0);
    pos[i] = vec4(pos[i].xyz + vel[i].xyz * dt, pos[i].w);
}
