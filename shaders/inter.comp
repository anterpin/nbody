#version 460


layout (local_size_x = 256) in;
layout (location = 1) uniform float G;
layout (location = 2) uniform float dt;
layout (location = 3) uniform float eps2;
layout (location = 4) uniform float damping;
layout (location = 5) uniform float threshold;
layout (location = 6) uniform int n2;
layout (location = 7) uniform int to_sort;


layout (binding = 0, std430) buffer positions
{
  vec4 pos[];
};

layout (binding = 1, std430) buffer velocities
{
  vec4 vel[];
};

layout (binding = 2, std430) buffer tree
{
  float sizes[];
};

layout (binding = 3, std430) buffer center_of_mass
{
  vec4 com[];
};

layout (binding = 4, std430) buffer children
{
  int chil[];
};

layout (binding = 5, std430) buffer next
{
  int nex[];
};

layout (binding = 6, std430) buffer sorted
{
  int sort[];
};

#ifdef CACHING
  #define CACHE_SIZE 2048
  shared int ind[CACHE_SIZE];
  shared vec4 ccom[CACHE_SIZE];
  shared float csizes[CACHE_SIZE];
  shared int cchil[CACHE_SIZE];
  shared int cnex[CACHE_SIZE];
#endif


vec3 interact(vec3 a, vec3 b, float m) {
  vec3 r = a - b;
  float ds = dot(r, r) + eps2;
  return r * m * inversesqrt(ds * ds * ds);
}

vec3 calc_acceleration(vec3 pos, bool first_thread) {
    int i = 0;
    vec3 acc = vec3(0);
    while (i != -1) {
#ifdef CACHING
      // int entry = i % CACHE_SIZE;
      int entry = i & 2047;

      vec4 cm;
      int ch;
      float sz;
      int nx;

      // TODO make it really atomic
      if (first_thread) {
        cm = com[i];
        sz = sizes[i];
        ch = chil[i];
        nx = nex[i];
        if (ind[entry] == -1) {
          ccom[entry] = cm;
          csizes[entry] = sz;
          cchil[entry] = ch;
          cnex[entry] = nx;
          ind[entry] = i;
        }
      } else {
        bool cond = ind[entry] == i;
        cm = cond ? ccom[entry] : com[i];
        sz = cond ? csizes[entry] : sizes[i];
        ch = cond ? cchil[entry] : chil[i];
        nx = cond ? cnex[entry] : nex[i];
      }
#else
      vec4 cm = com[i];
      float sz = sizes[i];
      int ch = chil[i];
      int nx = nex[i];
#endif
      bool cond = ch == 0 || (sz / distance(cm.xyz, pos)) < threshold;
      acc += cond ? interact(cm.xyz, pos, cm.w) : vec3(0);
      i = cond ? nx : ch;
    }
    return acc;
}


void main() {
    uint i = gl_GlobalInvocationID.x;
    uint n = pos.length();
    if (i >= n) {
      return;
    }
    if (to_sort == 1)
      i = sort[i];

    vec4 ps = pos[i];
    vec3 p = ps.xyz;

    vec3 a = vec3(0.0);
    if (n2 == 0) {
#ifdef CACHING
      // set cache
      for (int j = 0; j < CACHE_SIZE / gl_WorkGroupSize.x; j++) {
        ind[gl_WorkGroupSize.x * gl_LocalInvocationID.x + j] = -1;
      }
      memoryBarrierShared();
      barrier();
#endif
      a = calc_acceleration(p, gl_LocalInvocationID.x == 0);
    } else  {
      for (int k = 0; k < n; k++) {
        vec3 b = pos[k].xyz;
        a += interact(b, p, 1);
      }
    }

    vec3 v = vel[i].xyz;
    vel[i] = vec4(v * damping + a * G * dt, 0);
    pos[i] = vec4(p + v * dt, ps.w);
}
